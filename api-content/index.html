{"posts":[{"title":"防止请求参数SQL注入的正则表达式","content":"import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.regex.Pattern; /** * sql拦截器，防止sql注入 */ public class SqlInterceptor implements HandlerInterceptor { //放行请求列表 private List&lt;String&gt; exceptUrls; //获取放行请求列表 public void setExceptUrls(List&lt;String&gt; exceptUrls) { this.exceptUrls = exceptUrls; } /** * 正则表达式 * //b 表示 限定单词边界 比如 select 不通过 1select则是可以的 **/ private static String reg = &quot;(?:')|(?:--)|(/\\\\*(?:.|[\\\\n\\\\r])*?\\\\*/)|(\\\\b(select|update|union|and|or|insert|trancate|char|into|substr|ascii|declare|exec|count|master|into|drop|execute)\\\\b)&quot;; private static Pattern sqlPattern = Pattern.compile(reg, Pattern.CASE_INSENSITIVE); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest)request; Map&lt;String, Object&gt; params = ServletsUtil.getParameters(request); //对指定请求放行 for (String url:exceptUrls){ if(params.containsKey(&quot;diyContent&quot;)&amp;&amp;request.getRequestURI().equals(url)){ return true; } } //只对POST过滤，去掉此层if则对所有请求都过滤 if(!&quot;GET&quot;.equals(httpServletRequest.getMethod())){ for (Entry&lt;String, Object&gt; entry : params.entrySet()) { String str = entry.getValue().toString().toLowerCase(); if (sqlPattern.matcher(str).find()) { logger.info(&quot;拦截到SQL注入攻击：str=&quot; + str); //throw new ServiceException(&quot;未能通过sql过滤器&quot;); return false; } } } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } ","link":"https://wangcx.me/post/BQ0IDOkaf/"},{"title":"JSON数组转换树结构","content":"/** * * @param a json数组 * @param idStr id * @param pidStr 父id * @param childrenStr 子数组 * @returns {[]} */ export function transData(array, idStr, pidStr, childrenStr) { let r = [], hash = {}, id = idStr, pid = pidStr, children = childrenStr, i = 0, j = 0, len = array.length; for (; i &lt; len; i++) { hash[array[i][id]] = array[i]; } for (; j &lt; len; j++) { let aVal = array[j], hashVP = hash[aVal[pid]]; if (hashVP) { !hashVP[children] &amp;&amp; (hashVP[children] = []); hashVP[children].push(aVal); } else { r.push(aVal); } } return r; } ","link":"https://wangcx.me/post/n4Mn8cNrK/"},{"title":"Mac上用homebrew方式安装vue","content":"1、安装homebrew(如果已经安装过homebrew则跳过) /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2、通过brew方式安装node和npm brew install node 3、安装cnpm 基于node.js,利用淘宝npm镜像安装相关依赖。由于国内使用npm会很慢,推荐使用淘宝NPM镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 4、安装vue-cli npm install -g vue-cli ","link":"https://wangcx.me/post/edF1Oc9aD/"},{"title":"IDEA中隐藏不想看到的文件","content":"设置-&gt;编辑器-&gt;文件类型-&gt;忽略的文件和文件夹 添加 *.mvn *.gitignore *.md *.cmd mvnw 即可屏蔽 ","link":"https://wangcx.me/post/NB6MTqTzs/"},{"title":"Jetbrains产品无限重置30天试用方法","content":" 如何安装 1.插件市场安装： 在Settings/Preferences... -&gt; Plugins内手动添加第三方插件仓库地址：https://plugins.zhile.io 搜索：IDE Eval Reset插件进行安装。 2.下载安装： 下载插件的zip包，地址：https://plugins.zhile.io/files/ide-eval-resetter-2.1.15-3ef56c82.zip（macOS可能会自动解压，然后把zip包丢进回收站） 通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&gt; Plugins里手动安装插件（Install Plugin From Disk...） 插件会提示安装成功。 如何使用 一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示） 也可以手动唤出插件的主界面： 如果IDE没有打开项目，在Welcome界面点击菜单：Get Help -&gt; Eval Reset 如果IDE打开了项目，点击菜单：Help -&gt; Eval Reset 唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项： 按钮：Reload用来刷新界面上的显示信息。 按钮：Reset点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（此为手动重置方式） 勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式） 支持的产品 IntelliJ IDEA AppCode CLion DataGrip GoLand PhpStorm PyCharm Rider RubyMine WebStorm ","link":"https://wangcx.me/post/mBZpbwNXY/"},{"title":"MySQL插入时间错误问题","content":"在程序中进行update操作时候，发现插入时间错误，IDEA执行的sql与本机（北京时间）相差8个\b小时，而在Navicat直接执行，则不能复现问题 通过搜索得知问题在于jdbc的连接参数上，大多数博客给出的默认jdbc连接参数都类似： jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC 问题出在serverTimezone=UTC这个配置上，UTC，简称世界统一时间，跟北京时间相比，比北京早8个小时，如果定义了serverTimezone=UTC，那么在你编译器上执行的SQL语句，会先以UTC时区进行存储，发送到MySQL,然后MySQL以本地时区进行转换，就会导致，同一段SQL语句，在Navicat直接执行，与IDEA执行，结果不同 解决方案： 改为serverTimezone=GMT%2B8，GMT%2B8代表是东八区时间，也就是北京时间 或者serverTimezone=Asia/Shanghai，Asia/Shanghai代表上海时间，上海时间=北京时间=东八区时间 ","link":"https://wangcx.me/post/ikW5KCr7k/"},{"title":"JWT Token","content":"为什么使用JWT？ 随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 什么时候你应该用JSON Web Tokens 下列场景中使用JSON Web Token是很有用的： Authorization (授权) 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。 Information Exchange (信息交换) 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头部和有效负载计算的，您还可以验证内容没有被篡改。 JSON Web Token的结构是什么样的 JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是： Header（头部） Payload（载荷） Signature（签证） 因此，一个典型的JWT看起来是这个样子的： xxxxx.yyyyy.zzzzz 接下来，具体看一下每一部分： Header（头部）jwt的头部承载两部分信息： typ（声明类型） 这里是jwt alg（声明加密的算法） 通常直接使用 HMAC SHA256 例如： { &quot;typ&quot;:&quot;JWT&quot;, &quot;alg&quot;:&quot;HMAC&quot; } 然后，用Base64对这个JSON编码就得到JWT的第一部分 Payload（载荷）载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 Registered claims（标准中注册的声明,建议但不强制使用） iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的 iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 Public claims（公共的声明）公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密 Private claims（私有的声明）私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息 下面是一个例子： { &quot;name&quot;:&quot;wangcx&quot;, &quot;age&quot;:&quot;18&quot;, &quot;sex&quot;:&quot;男&quot; } 对payload进行Base64编码就得到JWT的第二部分 注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的 Signature（签证）jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好 JSON Web Tokens是如何工作的 应用（或者客户端）向授权服务器请求授权。 当授权被许可以后，授权服务器返回一个access token给应用 应用使用access token访问受保护的资源（比如：API） ","link":"https://wangcx.me/post/fAFtr36RJ/"},{"title":"shiro权限注解","content":"Shiro 提供了相应的注解用于权限控制，如果使用这些注解就需要使用AOP 的功能来进行判断，如Spring AOP；Shiro 提供了Spring AOP 集成用于权限注解的解析和验证。 @RequiresAuthentication 表示当前Subject已经通过login 进行了身份验证；即Subject.isAuthenticated()返回true。 @RequiresUser 表示当前Subject已经身份验证或者通过记住我登录的。 @RequiresGuest 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresRoles(value={&quot;admin&quot;, &quot;user&quot;}, logical= Logical.AND) @RequiresRoles(value={&quot;admin&quot;}) @RequiresRoles({&quot;admin&quot;}) 表示当前Subject需要角色admin 和user。 @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) 表示当前Subject需要权限user:a或user:b。 Shiro的认证注解处理是有内定的处理顺序的，如果有多个注解的话，前面的通过了会继续检查后面的，若不通过则直接返回，处理顺序依次为（与实际声明顺序无关） 1. RequiresRoles 2. RequiresPermissions 3. RequiresAuthentication 4. RequiresUser 5. RequiresGuest 以上注解既可以用在controller中，也可以用在service中使用； 建议将shiro注解放在controller中，因为如果service层使用了spring的事物注解，那么shiro注解将无效。 ","link":"https://wangcx.me/post/qgKue1rWa/"},{"title":"GitHub文件下载加速","content":"github上有非常多的开源项目，可每次下载的时候速度却非常慢，分享几个提供在线加速的网站 http://toolwa.com/github https://d.serctl.com https://gh.api.99988866.xyz https://g.ioiox.com http://gitd.cc https://gh.sky-and-poem.fun https://github.zhlh6.cn ","link":"https://wangcx.me/post/EMSDlYCwH/"},{"title":"VUE学习笔记二","content":"单向双向数据流及事件绑定 单向数据流绑定属性值v-bind:(属性)简写为:(属性) &lt;input v-bind:value=&quot;name&quot; :class=&quot;name&quot; /&gt; 双向数据流v-model只作用于有value属性的元素 &lt;input v-model=&quot;name&quot; v-bind:class&quot;name&quot; /&gt; 事件绑定v-on:事件名=&quot;表达式||函数名&quot;简写@名事件名=&quot;表达式||函数名&quot; 事件名可以是原生也可以是自定义 所有示例如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; var vm=new Vue({ el:'#app', template:`&lt;div&gt; 单向数据绑定： &lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot; :class=&quot;name&quot; /&gt; &lt;br&gt; 双向数据绑定 &lt;input type=&quot;text&quot; v-model:value=&quot;name&quot; /&gt; &lt;br&gt; {{name}} &lt;br&gt; &lt;button v-on:click=&quot;change&quot;&gt; click me &lt;/button&gt; &lt;/div&gt;`, data:function(){ return {name:&quot;hello&quot;} }, methods:{change:function(){ this.name='change ok' }} }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://wangcx.me/post/3YY2qSwa0/"},{"title":"VUE学习笔记一","content":"下载安装node 执行如下命令安装vue(如需下载特定版本在vue后边加上@版本号，例如：vue@2.5) cnpm为国内镜像站 cnpm install vue 页面引入vue.js &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt; 页面上预留vue模板插入的位置 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 实例化vue new Vue({el:预留位置,template:模板内容}); #实例化传入的是一个对象options options： el 对应上边预留的vue模板位置，可通过id，类名，标签名查找，方式等同jquery； template 内容 data 数据，值为函数形式，也可以是对象，但都是用函数，因为用的函数最后也是return一个对象 插值表达式 插值表达式内填入data里面的变量即可在页面取到变量值{{data里的变量}} 代码示例 &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', template:`&lt;div&gt;你好，世界，{{text}}&lt;/div&gt;`, data:function(){ return{ text:'这是vue的测试', } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://wangcx.me/post/Zw-aD_R6u/"},{"title":"Homebrew 修改源","content":"切换brew源为国内镜像站 替换brew.git cd &quot;$(brew --repo)&quot; 中国科大源 git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 清华大学源 git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git 替换homebrew-core.git: cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; 中国科大源 git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 清华大学源 git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git 替换homebrew-bottles: 中国科大源 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile source ~/.bash_profile 清华大学源 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile source ~/.bash_profile 应用生效 brew update 切换brew源为默认值 重置brew.git cd &quot;$(brew --repo)&quot; git remote set-url origin https://github.com/Homebrew/brew.git 重置homebrew-core.git cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; git remote set-url origin https://github.com/Homebrew/homebrew-core.git ","link":"https://wangcx.me/post/3nM-03keu/"},{"title":"Mac下安装HomeBrew","content":"运行以下自动安装脚本（官方脚本）： /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 国内脚本： 安装脚本： /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 卸载脚本： /bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot; ","link":"https://wangcx.me/post/UZRPlBp0k/"},{"title":"屏蔽MacOS Catalina的更新","content":"MacOS Mojave软件更新变为独立的功能存在于系统偏好设置里面，并且可以直接自动检测大版本的升级。Catalina系统刚放出还有不少bug，而且从Catalina开始不支持32程序了。所以我并不想升级到MacOS Catalina，但是每次看到软件更新的小红点，强迫症发作。以下这个办法可以屏蔽已经检测到的升级，并且去掉烦人的小红点。 在终端输入 defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 然后输入 killall Dock 注意：这个不是永久性屏蔽，只要点软件更新就会再次出现。Catalina的更新提示是会和Mojave补丁的一起出现的，升级了安全更新再用终端屏蔽一次就好了。 ","link":"https://wangcx.me/post/V1qrPLxWE/"},{"title":"1024，节日快乐","content":"1024程序员节是中国广大程序员的共同节日。1024是2的十次方，二进制计数的基本计量单位之一。程序员(英文Programmer)是从事前端、后端程序开发、系统运维、测试等的专业人员。程序员就像是一个个1024，以最低调、踏实、核心的功能模块搭建起这个科技世界。1G=1024M，而1G与1级谐音，也有一级棒的意思。 ","link":"https://wangcx.me/post/edhk_1Os9/"},{"title":"macOS JDK多版本配置及切换","content":"首先安装需要的JDK版本 略. 配置JDK 创建.bash_profile配置文件（已经有该文件就跳过此步骤） touch ~/.bash_profile vim编辑.bash_profile文件 vim ~/.bash_profile 如果不习惯vim命令就使用自带的文本编辑器打开 open ~/.bash_profile 设置jdk版本 export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.4.jdk/Contents/Home export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home export JAVA_HOME=$JAVA_8_HOME alias命令动态切换JAVA_HOME的配置 alias jdk8='export JAVA_HOME=$JAVA_8_HOME' alias jdk11='export JAVA_HOME=$JAVA_11_HOME' 输入完成后保存执行下面命令,重新执行.bash_profile文件 source ~/.bash_profile 这样以后即可在终端中使用jdk8或者jdk11切换jdk版本了 ","link":"https://wangcx.me/post/q7KSfPGKv/"},{"title":"换了2019 MacBook Pro 15","content":"以前的笔记本是几年前买的，雷神G150T（好像是这个型号吧），四代i7标压处理器，8g内存，后来自己又加装了一条128的SSD，服役多年，而且idea跑的项目一多，风扇转的呼呼的，内存也时不时告警，于是萌生了换macbook的想法 一是之前用macOS觉得使用体验不错，二是一台macbook正常使用条件下，寿命远远大于同等的windows笔记本，这样算下来，其实价格也比较合算，又加上有教育优惠，白送一个Beats Studio3 Wireless耳机 嗯，真香，mac大法好 ps：非在校学生，教育优惠可求助万能的某宝！ ","link":"https://wangcx.me/post/u-btB0Tzx/"},{"title":"博客换到GitHub","content":"博客每次都换来换去，用过emlog，typecho，wordpress但是都因为这样那样的原因没有坚持下去，最终换到github了，不出意外的话，应该不折腾了，一方面没有太多的时间和精力，另一方面是因为发现换博客的次数远远大于更新博客的次数，有违初衷。 ","link":"https://wangcx.me/post/u2ARg23Bp/"}]}